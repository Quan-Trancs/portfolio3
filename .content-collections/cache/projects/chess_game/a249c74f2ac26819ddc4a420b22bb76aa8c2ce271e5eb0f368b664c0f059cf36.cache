{"content":"A chess game implementation featuring an AI opponent that uses the min-max algorithm for intelligent move selection. The project demonstrates advanced algorithm design principles, game tree traversal, and decision-making strategies in a classic board game context. Built using Prolog, showcasing declarative programming approaches to game logic.\n\n## Key Features\n\n**AI Implementation**\n- Min-Max algorithm for optimal move selection\n- Alpha-Beta pruning for efficiency\n- Evaluation function for board position assessment\n- Configurable search depth\n\n**Game Logic**\n- Complete chess rules implementation\n- Move validation and legal move generation\n- Check and checkmate detection\n- Board state representation\n\n## Technical Highlights\n\nDeveloped using SWI-Prolog, a robust Prolog implementation. Utilizes declarative programming paradigms to represent chess rules and game logic. Implements min-max algorithm with alpha-beta pruning optimization to reduce computational complexity while maintaining optimal decision-making.","title":"Chess Game with Min-Max Algorithm","description":"A chess game implementation featuring an AI opponent using the min-max algorithm for intelligent move selection.","github":"https://github.com/Quan-Trancs/CSE259_Prj2_Chess","tags":[{"label":"Prolog"},{"label":"SWI-Prolog"},{"label":"Min-Max Algorithm"},{"label":"Alpha-Beta Pruning"},{"label":"Game AI"},{"label":"Chess"},{"label":"Algorithm Design"},{"label":"Tree Traversal"},{"label":"Declarative Programming"}],"date":"2023-10-30","startDate":"2023-09-01","endDate":"2023-10-30","category":"Machine Learning","_meta":{"filePath":"chess_game.mdx","fileName":"chess_game.mdx","directory":".","extension":"mdx","path":"chess_game"},"toc":[{"title":"Key Features","url":"#key-features","depth":2},{"title":"Technical Highlights","url":"#technical-highlights","depth":2}],"structuredData":{"contents":[{"content":"A chess game implementation featuring an AI opponent that uses the min-max algorithm for intelligent move selection. The project demonstrates advanced algorithm design principles, game tree traversal, and decision-making strategies in a classic board game context. Built using Prolog, showcasing declarative programming approaches to game logic."},{"heading":"key-features","content":"AI Implementation"},{"heading":"key-features","content":"Min-Max algorithm for optimal move selection"},{"heading":"key-features","content":"Alpha-Beta pruning for efficiency"},{"heading":"key-features","content":"Evaluation function for board position assessment"},{"heading":"key-features","content":"Configurable search depth"},{"heading":"key-features","content":"Game Logic"},{"heading":"key-features","content":"Complete chess rules implementation"},{"heading":"key-features","content":"Move validation and legal move generation"},{"heading":"key-features","content":"Check and checkmate detection"},{"heading":"key-features","content":"Board state representation"},{"heading":"technical-highlights","content":"Developed using SWI-Prolog, a robust Prolog implementation. Utilizes declarative programming paradigms to represent chess rules and game logic. Implements min-max algorithm with alpha-beta pruning optimization to reduce computational complexity while maintaining optimal decision-making."}],"headings":[{"id":"key-features","content":"Key Features"},{"id":"technical-highlights","content":"Technical Highlights"}]},"body":"var Component=(()=>{var d=Object.create;var o=Object.defineProperty;var g=Object.getOwnPropertyDescriptor;var p=Object.getOwnPropertyNames;var u=Object.getPrototypeOf,f=Object.prototype.hasOwnProperty;var x=(i,e)=>()=>(e||i((e={exports:{}}).exports,e),e.exports),v=(i,e)=>{for(var t in e)o(i,t,{get:e[t],enumerable:!0})},r=(i,e,t,l)=>{if(e&&typeof e==\"object\"||typeof e==\"function\")for(let a of p(e))!f.call(i,a)&&a!==t&&o(i,a,{get:()=>e[a],enumerable:!(l=g(e,a))||l.enumerable});return i};var _=(i,e,t)=>(t=i!=null?d(u(i)):{},r(e||!i||!i.__esModule?o(t,\"default\",{value:i,enumerable:!0}):t,i)),j=i=>r(o({},\"__esModule\",{value:!0}),i);var s=x((k,c)=>{c.exports=_jsx_runtime});var M={};v(M,{default:()=>h});var n=_(s());function m(i){let e={h2:\"h2\",li:\"li\",p:\"p\",strong:\"strong\",ul:\"ul\",...i.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(e.p,{children:\"A chess game implementation featuring an AI opponent that uses the min-max algorithm for intelligent move selection. The project demonstrates advanced algorithm design principles, game tree traversal, and decision-making strategies in a classic board game context. Built using Prolog, showcasing declarative programming approaches to game logic.\"}),`\n`,(0,n.jsx)(e.h2,{id:\"key-features\",children:\"Key Features\"}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"AI Implementation\"})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Min-Max algorithm for optimal move selection\"}),`\n`,(0,n.jsx)(e.li,{children:\"Alpha-Beta pruning for efficiency\"}),`\n`,(0,n.jsx)(e.li,{children:\"Evaluation function for board position assessment\"}),`\n`,(0,n.jsx)(e.li,{children:\"Configurable search depth\"}),`\n`]}),`\n`,(0,n.jsx)(e.p,{children:(0,n.jsx)(e.strong,{children:\"Game Logic\"})}),`\n`,(0,n.jsxs)(e.ul,{children:[`\n`,(0,n.jsx)(e.li,{children:\"Complete chess rules implementation\"}),`\n`,(0,n.jsx)(e.li,{children:\"Move validation and legal move generation\"}),`\n`,(0,n.jsx)(e.li,{children:\"Check and checkmate detection\"}),`\n`,(0,n.jsx)(e.li,{children:\"Board state representation\"}),`\n`]}),`\n`,(0,n.jsx)(e.h2,{id:\"technical-highlights\",children:\"Technical Highlights\"}),`\n`,(0,n.jsx)(e.p,{children:\"Developed using SWI-Prolog, a robust Prolog implementation. Utilizes declarative programming paradigms to represent chess rules and game logic. Implements min-max algorithm with alpha-beta pruning optimization to reduce computational complexity while maintaining optimal decision-making.\"})]})}function h(i={}){let{wrapper:e}=i.components||{};return e?(0,n.jsx)(e,{...i,children:(0,n.jsx)(m,{...i})}):m(i)}return j(M);})();\n;return Component;"}